//
// SPDX-License-Identifier: MIT
// Copyright (c) 2025 Matthias Melcher, robowerk.de
//

#include "common/Endpoints/Dock.h"

#include "main.h"

#include <stdio.h>
#include <cstring>

using namespace nd; 

/**
 * \class nd::Dock
 * \brief This class implements useful parts of the Newton docking protocol.
 * 
 * The Newton Docking protocol connects NewtoOS machines to the outside world.
 * It's used to sync and backup the device, install software, emulate a 
 * keyboard, and much more.
 * 
 * Technically, the Dock protocol is a full duplex binary data stream. The
 * streams are interpreted as commands followed by a 32 bit size field, then
 * by `size` bytes of data, and finally padded with 0's to a 4 byte boundary.
 *
 * There is not true block synchronisation or error detection on this level.
 * The MNP Filter however indicates the start and end of a block when MNP
 * encoded data was received.
 * 
 * Docking commands always start with `newt` and `dock`, followed by a four byte
 * command code.
 * 
 * \note The docking handshake and protocol is described elsewhere.
 */


 /* TODO
  - we need a structure that holds a chunk of data
    - the data and the size of the data
    - the current position that we want to send
	- flag if we want to start with a start fram marker
	- flag if we want to end with an end frame marker
	- flag if the data needs to be freed after sending
  - we need a queue of these structures
  - we need a state machine that handles the sending of these structures
	- it needs to handle the start and end frame markers
	- it needs to handle the data size and position
	- it needs to handle the freeing of the data after sending
  */

Result Dock::task() {
	if (!data_queue_.empty()) {
		Data &data = data_queue_.front();
		if (data.start_frame_) {
			// If we have a start frame, we send it first.
			if (out()->send(Event(Event::Type::MNP, Event::Subtype::MNP_FRAME_START)).rejected()) {
				return Result::REJECTED;
			} else {
				data.start_frame_ = false; // we sent the start frame, no need to send it again
				return Result::OK;
			}
		}
		if (data.pos_ < data.size_) {
			// If we have data to send, we send it.
			if (out()->send(Event(Event::Type::DATA, Event::Subtype::NIL, data.data_[data.pos_])).rejected()) {
				return Result::REJECTED;
			} else {
				data.pos_++; // we sent the next byte
				return Result::OK;
			}
		}
		if (data.end_frame_) {
			// If we have an end frame, we send it last.
			if (out()->send(Event(Event::Type::MNP, Event::Subtype::MNP_FRAME_END)).rejected()) {
				return Result::REJECTED;
			} else {
				data.end_frame_ = false; // we sent the end frame, no need to send it again
			}
		}
		data_queue_.pop();
		if (data.free_after_send_ && data.data_) {
			delete[] data.data_;
		}
	}
	return super::task();
}

Result Dock::send(Event event) {
	// TODO: for now, simply log all the stuff that we receive.

	if (event.type() == Event::Type::MNP) {
		switch (event.subtype()) {
			case Event::Subtype::MNP_CONNECTED: // data() is index in out_pool
				if (kLogDock) Log.log("Dock::send: MNP_CONNECTED\r\n");
				break;
			case Event::Subtype::MNP_DISCONNECTED: // data() is index in out_pool
				if (kLogDock) Log.log("Dock::send: MNP_DISCONNECTED\r\n");
				break;
			case Event::Subtype::MNP_FRAME_START: // data() is index in out_pool
				if (kLogDock) Log.log("Dock::send: MNP_FRAME_START\r\n");
				break;
			case Event::Subtype::MNP_FRAME_END: // data() is index in out_pool
				if (kLogDock) Log.log("Dock::send: MNP_FRAME_END\r\n");
				break;
			default:
				if (kLogDock) Log.logf("Dock::send: MNP event %d\r\n", static_cast<int>(event.subtype()));
				break;
		}
	} else if (event.type() == Event::Type::DATA) {
		if (kLogDock) Log.logf("#%02x ", event.data());
		uint8_t c = event.data();
		switch (state_) {
			case  0: 
				if (c == 'n') {
					state_++; 
				} else {
					Log.logf("\r\nERROR: Dock::send: State out of sync!\r\n", cmd_, size);
				}
				break; // 'n'
			case  1: if (c == 'e') state_++; else state_ = 0; break; // 'e'
			case  2: if (c == 'w') state_++; else state_ = 0; break; // 'w'
			case  3: if (c == 't') state_++; else state_ = 0; break; // 't'
			case  4: if (c == 'd') state_++; else state_ = 0; break; // 'd'
			case  5: if (c == 'o') state_++; else state_ = 0; break; // 'o'
			case  6: if (c == 'c') state_++; else state_ = 0; break; // 'c'
			case  7: if (c == 'k') state_++; else state_ = 0; break; // 'k'
			case  8: cmd_[0] = c; state_++; break;
			case  9: cmd_[1] = c; state_++; break;
			case 10: cmd_[2] = c; state_++; break;
			case 11: cmd_[3] = c; state_++; break;
			case 12: size = (c<<24); state_++; break;
			case 13: size |= (c<<16); state_++; break;
			case 14: size |= (c<<8); state_++; break;
			case 15: 
				size |= c;
				if (kLogDock) Log.logf("\r\nDock::send: Receiving '%s' stream with %d bytes.\r\n", cmd_, size);
				in_data_.clear();
				in_index_ = 0;
				if (size==0) {
					process_command();
					state_ = 0; 
				} else {
					aligned_size = (size + 3) & ~3;
					state_++;
				}
				break;
			case 16:
				if (in_index_ < size) {
					in_data_.push_back(c);
					in_index_++;
				}
				if (in_index_ == aligned_size) {
					// We have received all the data, process the command.
					if (kLogDock) Log.logf("Dock::send: Received '%s' command with %d bytes.\r\n", cmd_, size);
					process_command();
					state_ = 0; // reset state
				}
				break;
		}
	} else {
		if (kLogDock) Log.logf("Dock::send: Unknown event type %d\r\n", static_cast<int>(event.type()));
	}

	return super::send(event);
}

void Dock::process_command() {
	switch (cmd) {
		case ND_FOURCC('r', 't', 'd', 'k'): // rtdk, ready to dock
			reply_dock(); break;
		case ND_FOURCC('n', 'a', 'm', 'e'): // name, and lots of other data
			reply_stim(); break;
		case ND_FOURCC('d', 'r', 'e', 's'): // dres, some result for on of the previous messages?
			if (!package_sent) {
				// We have not sent a package yet, so we send the lpkg.
				reply_lpkg();
				package_sent = true; // we sent a package
			} else {
				reply_disc(); break;
			}
			break;
		default:
			if (kLogDock) Log.logf("Dock::process_command: Unknown command '%s' (%08x)\r\n", cmd_, cmd);
			break;
	}
}


void Dock::reply_dock() {
	if (kLogDock) Log.log("Dock: reply_dock\r\n");
	static uint8_t data[] = {
		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b,
		0x64, 0x6f, 0x63, 0x6b, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x04
	};
	data_queue_.push(Dock::Data {
		.data_ = data,
		.size_ = sizeof(data),
		.pos_ = 0,
		.start_frame_ = true, // we want to start with a start frame marker
		.end_frame_ = true, // we want to end with an end frame marker
		.free_after_send_ = false, // we don't want to free the data after sending
	});
}

void Dock::reply_stim() {
	if (kLogDock) Log.log("Dock: reply_stim\r\n");
	static uint8_t data[] = {
		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b,
		0x73, 0x74, 0x69, 0x6d, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x5A
	};
	data_queue_.push(Dock::Data {
		.data_ = data,
		.size_ = sizeof(data),
		.pos_ = 0,
		.start_frame_ = true, // we want to start with a start frame marker
		.end_frame_ = true, // we want to end with an end frame marker
		.free_after_send_ = false, // we don't want to free the data after sending
	});
}

void Dock::reply_disc() {
	if (kLogDock) Log.log("Dock: reply_disc\r\n");
	static uint8_t data[] = {
		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b,
		0x64, 0x69, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00
	};
	data_queue_.push(Dock::Data {
		.data_ = data,
		.size_ = sizeof(data),
		.pos_ = 0,
		.start_frame_ = true, // we want to start with a start frame marker
		.end_frame_ = true, // we want to end with an end frame marker
		.free_after_send_ = false, // we don't want to free the data after sending
	});
}

void Dock::reply_lpkg() {
	if (kLogDock) Log.log("Dock: reply_lpkg\r\n");
	static uint8_t data[] = {

		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b, 
		0x6c, 0x70, 0x6b, 0x67, 0x00, 0x00, 0x08, 0xa4, // lpkg, 184*12+4

  0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x31, 0x78, 0x78, 0x78, 0x78,
  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62,
  0x00, 0x62, 0x00, 0x16, 0x00, 0x00, 0x08, 0xa4, 0xaf, 0x7b, 0xb9, 0xd5,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0c,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x98,
  0x00, 0x00, 0x07, 0x98, 0x61, 0x75, 0x74, 0x6f, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x81, 0x00, 0x78, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xa9, 0x00, 0x31, 0x00, 0x39, 0x00, 0x39, 0x00, 0x36, 0x00, 0x20,
  0x00, 0x41, 0x00, 0x70, 0x00, 0x70, 0x00, 0x6c, 0x00, 0x65, 0x00, 0x20,
  0x00, 0x43, 0x00, 0x6f, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x75, 0x00, 0x74,
  0x00, 0x65, 0x00, 0x72, 0x00, 0x2c, 0x00, 0x20, 0x00, 0x49, 0x00, 0x6e,
  0x00, 0x63, 0x00, 0x2e, 0x00, 0x20, 0x00, 0x20, 0x00, 0x41, 0x00, 0x6c,
  0x00, 0x6c, 0x00, 0x20, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68,
  0x00, 0x74, 0x00, 0x73, 0x00, 0x20, 0x00, 0x72, 0x00, 0x65, 0x00, 0x73,
  0x00, 0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x64, 0x00, 0x2e,
  0x00, 0x00, 0x00, 0x53, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x6d, 0x00, 0x6f,
  0x00, 0x6e, 0x00, 0x3a, 0x00, 0x44, 0x00, 0x54, 0x00, 0x53, 0x00, 0x00,
  0x61, 0x75, 0x74, 0x6f, 0x4e, 0x65, 0x77, 0x74, 0x6f, 0x6e, 0xaa, 0x20,
  0x54, 0x6f, 0x6f, 0x6c, 0x4b, 0x69, 0x74, 0x20, 0x50, 0x61, 0x63, 0x6b,
  0x61, 0x67, 0x65, 0x20, 0xa9, 0x20, 0x31, 0x39, 0x39, 0x32, 0x2d, 0x31,
  0x39, 0x39, 0x35, 0x2c, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x20, 0x43,
  0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x2c, 0x20, 0x49, 0x6e, 0x63,
  0x2e, 0x00, 0xff, 0xff, 0x00, 0x00, 0x10, 0x41, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x1d, 0x00, 0x00, 0x18, 0x43,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x00, 0x00, 0x01, 0xb5,
  0x00, 0x00, 0x03, 0x99, 0x00, 0x00, 0x07, 0x59, 0x00, 0x00, 0x1c, 0x41,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x01, 0x51, 0x00, 0x00, 0x01, 0x71, 0x00, 0x00, 0x01, 0x95,
  0x00, 0x00, 0x1e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x81, 0x91, 0x61, 0x8c, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x53,
  0x63, 0x72, 0x69, 0x70, 0x74, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x21, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x53, 0xe4, 0x69, 0xb3,
  0x64, 0x65, 0x76, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x53, 0x63,
  0x72, 0x69, 0x70, 0x74, 0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x20, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x36, 0x12, 0xb3, 0xf2,
  0x64, 0x65, 0x76, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x53, 0x63, 0x72,
  0x69, 0x70, 0x74, 0x00, 0x00, 0x00, 0x24, 0x43, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0xd9, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x02, 0xa9,
  0x00, 0x00, 0x02, 0xc5, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x04,
  0x00, 0x00, 0x03, 0x35, 0x00, 0x00, 0x28, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0x01,
  0x00, 0x00, 0x02, 0x19, 0x00, 0x00, 0x02, 0x39, 0x00, 0x00, 0x02, 0x55,
  0x00, 0x00, 0x02, 0x71, 0x00, 0x00, 0x02, 0x89, 0x00, 0x00, 0x16, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x25, 0x0b, 0xd4, 0x46,
  0x63, 0x6c, 0x61, 0x73, 0x73, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x1d, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x83, 0xa6, 0x3a, 0xcd,
  0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
  0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x19, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0xc3, 0xc1, 0x17, 0x60, 0x6c, 0x69, 0x74, 0x65,
  0x72, 0x61, 0x6c, 0x73, 0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x19, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x13, 0xe7, 0x40, 0xdd,
  0x61, 0x72, 0x67, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x00, 0xbf, 0xbf, 0xbf,
  0x00, 0x00, 0x18, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x5b, 0x3c, 0x3b, 0xf5, 0x6e, 0x75, 0x6d, 0x41, 0x72, 0x67, 0x73, 0x00,
  0x00, 0x00, 0x1d, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x7c, 0xe9, 0xe5, 0xa9, 0x44, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72,
  0x49, 0x6e, 0x66, 0x6f, 0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x1c, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x19, 0x7b, 0x18, 0x91, 0x19,
  0x81, 0x1a, 0x29, 0xa4, 0x7b, 0x7c, 0x7b, 0x1b, 0x3a, 0x00, 0x7c, 0x02,
  0x00, 0x00, 0x1c, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x39,
  0x00, 0x00, 0x01, 0x95, 0x00, 0x00, 0x02, 0xe1, 0x00, 0x00, 0x03, 0x15,
  0x00, 0x00, 0x01, 0x71, 0x00, 0x00, 0x14, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0xf5,
  0x00, 0x00, 0x1d, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x63, 0xbf, 0xab, 0xcb, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x53, 0x63,
  0x72, 0x69, 0x70, 0x74, 0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x1f, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0xea, 0x16, 0x3c, 0xf7,
  0x45, 0x6e, 0x73, 0x75, 0x72, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,
  0x61, 0x6c, 0x00, 0xbf, 0x00, 0x00, 0x18, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x65,
  0x00, 0x00, 0x03, 0x81, 0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0xfb, 0x0a, 0xc5, 0x8e, 0x64, 0x62, 0x67, 0x31,
  0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x1a, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0x8e, 0x0e, 0x79, 0x12, 0x70, 0x61, 0x72, 0x74,
  0x46, 0x72, 0x61, 0x6d, 0x65, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x17, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x06, 0x6e, 0x96, 0x95,
  0x72, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x00, 0xbf, 0x00, 0x00, 0x24, 0x43,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd9, 0x00, 0x00, 0x00, 0x32,
  0x00, 0x00, 0x03, 0xbd, 0x00, 0x00, 0x03, 0xd1, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x07, 0x25, 0x00, 0x00, 0x11, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x19, 0x18, 0x19, 0x1a, 0x32,
  0x02, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x18, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x39, 0x00, 0x00, 0x03, 0xe9, 0x00, 0x00, 0x04, 0x05,
  0x00, 0x00, 0x04, 0xc9, 0x00, 0x00, 0x1b, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0x24, 0xbe, 0x15, 0xb7, 0x53, 0x61, 0x6c, 0x6d,
  0x6f, 0x6e, 0x3a, 0x44, 0x54, 0x53, 0x00, 0xbf, 0x00, 0x00, 0x14, 0x43,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x19, 0x00, 0x00, 0x04, 0x61,
  0x00, 0x00, 0x04, 0xb1, 0x00, 0x00, 0x18, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x31,
  0x00, 0x00, 0x04, 0x49, 0x00, 0x00, 0x16, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0x8f, 0xa5, 0x88, 0xf2, 0x74, 0x69, 0x74, 0x6c,
  0x65, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x16, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0xb4, 0xff, 0x1b, 0xc7, 0x63, 0x6f, 0x6c, 0x6f,
  0x72, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x04, 0x99, 0x00, 0x53, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x6d,
  0x00, 0x6f, 0x00, 0x6e, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x20,
  0x00, 0x50, 0x00, 0x75, 0x00, 0x66, 0x00, 0x66, 0x00, 0x20, 0x00, 0x50,
  0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00, 0x79, 0x00, 0x00,
  0x00, 0x00, 0x17, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x18, 0x10, 0xf3, 0x5f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x00, 0xbf,
  0x00, 0x00, 0x15, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x1e, 0x4f, 0x7f, 0x22, 0x70, 0x69, 0x6e, 0x6b, 0x00, 0xbf, 0xbf, 0xbf,
  0x00, 0x00, 0x24, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd9,
  0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x04, 0xed, 0x00, 0x00, 0x05, 0x21,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x06, 0xe1,
  0x00, 0x00, 0x33, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x19,
  0x18, 0x19, 0x29, 0x1a, 0x29, 0xc5, 0x6f, 0x00, 0x12, 0x18, 0x1b, 0x29,
  0x1c, 0x1d, 0x29, 0x1e, 0x2a, 0x00, 0x18, 0x19, 0x29, 0x7b, 0x1b, 0x29,
  0x7c, 0x98, 0x1f, 0x00, 0x07, 0x1f, 0x00, 0x08, 0x22, 0x24, 0x1f, 0x00,
  0x09, 0x2c, 0x02, 0xbf, 0x00, 0x00, 0x34, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x39, 0x00, 0x00, 0x05, 0x55, 0x00, 0x00, 0x05, 0x79,
  0x00, 0x00, 0x05, 0x99, 0x00, 0x00, 0x03, 0x15, 0x00, 0x00, 0x05, 0xb1,
  0x00, 0x00, 0x05, 0xcd, 0x00, 0x00, 0x05, 0xe9, 0x00, 0x00, 0x06, 0x09,
  0x00, 0x00, 0x06, 0x25, 0x00, 0x00, 0x06, 0xb9, 0x00, 0x00, 0x24, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0xb6, 0x2a, 0xb9, 0x5b,
  0x43, 0x68, 0x65, 0x7a, 0x44, 0x54, 0x53, 0x52, 0x65, 0x67, 0x69, 0x73,
  0x74, 0x72, 0x79, 0x3a, 0x44, 0x54, 0x53, 0x00, 0x00, 0x00, 0x1d, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x0c, 0xdd, 0x2d, 0x2a,
  0x47, 0x65, 0x74, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x56, 0x61, 0x72,
  0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x18, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0xc2, 0x77, 0xc6, 0x0f, 0x49, 0x73, 0x46, 0x72,
  0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x0c, 0x43, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x05, 0xbd, 0x00, 0x00, 0x10, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x1b, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0xda, 0x0a, 0xf0, 0x0d,
  0x54, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6c, 0x6f, 0x6e, 0x65, 0x00, 0xbf,
  0x00, 0x00, 0x1d, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x8b, 0x2e, 0x17, 0xe1, 0x44, 0x65, 0x66, 0x47, 0x6c, 0x6f, 0x62, 0x61,
  0x6c, 0x56, 0x61, 0x72, 0x00, 0xbf, 0xbf, 0xbf, 0x00, 0x00, 0x1c, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0x7e, 0xfe, 0xbe, 0xea,
  0x43, 0x68, 0x65, 0x7a, 0x44, 0x54, 0x53, 0x3a, 0x44, 0x54, 0x53, 0x00,
  0x00, 0x00, 0x24, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd9,
  0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x06, 0x49, 0x00, 0x00, 0x06, 0x69,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x1e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x19,
  0x18, 0x28, 0x19, 0x91, 0x6f, 0x00, 0x10, 0x18, 0x28, 0x19, 0x91, 0x1a,
  0x40, 0x5f, 0x00, 0x11, 0x22, 0x02, 0xbf, 0xbf, 0x00, 0x00, 0x18, 0x41,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x39, 0x00, 0x00, 0x06, 0x81,
  0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x06, 0x99, 0x00, 0x00, 0x18, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0xae, 0xc0, 0x90, 0x04,
  0x47, 0x65, 0x74, 0x52, 0x6f, 0x6f, 0x74, 0x00, 0x00, 0x00, 0x1e, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0xc0, 0x15, 0x2e, 0x3f,
  0x54, 0x68, 0x69, 0x6e, 0x67, 0x73, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65,
  0x64, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x26, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0x3e, 0x96, 0x23, 0xc8, 0x41, 0x64, 0x64, 0x50,
  0x72, 0x6f, 0x63, 0x72, 0x61, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x65,
  0x64, 0x43, 0x61, 0x6c, 0x6c, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x18, 0x41,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x4d, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x06, 0xf9, 0x00, 0x00, 0x07, 0x0d, 0x00, 0x00, 0x14, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52, 0xe3, 0xf5, 0x64, 0xf1,
  0x73, 0x79, 0x6d, 0x00, 0x00, 0x00, 0x16, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0x58, 0xa9, 0x99, 0x53, 0x66, 0x72, 0x61, 0x6d,
  0x65, 0x00, 0xbf, 0xbf, 0x00, 0x00, 0x18, 0x41, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x65,
  0x00, 0x00, 0x07, 0x3d, 0x00, 0x00, 0x1c, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x05, 0x55, 0x52, 0xe0, 0xc7, 0x45, 0x31, 0x72, 0x65, 0x6d, 0x6f,
  0x76, 0x65, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x00, 0x00, 0x00, 0x24, 0x43,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd9, 0x00, 0x00, 0x00, 0x32,
  0x00, 0x00, 0x07, 0x7d, 0x00, 0x00, 0x07, 0x8d, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x08, 0x91, 0x00, 0x00, 0x10, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x19, 0x18, 0x19, 0x31, 0x02,
  0x00, 0x00, 0x14, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x39,
  0x00, 0x00, 0x03, 0xe9, 0x00, 0x00, 0x07, 0xa1, 0x00, 0x00, 0x24, 0x43,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd9, 0x00, 0x00, 0x00, 0x32,
  0x00, 0x00, 0x07, 0xc5, 0x00, 0x00, 0x07, 0xe1, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x08, 0x7d, 0x00, 0x00, 0x1a, 0x40,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x19, 0x18, 0x19, 0x29, 0x7b,
  0x1a, 0x2a, 0x00, 0x1b, 0x1c, 0x22, 0x24, 0x1d, 0x2c, 0x02, 0xbf, 0xbf,
  0x00, 0x00, 0x24, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x39,
  0x00, 0x00, 0x05, 0x55, 0x00, 0x00, 0x05, 0x79, 0x00, 0x00, 0x08, 0x05,
  0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x08, 0x21, 0x00, 0x00, 0x06, 0xb9,
  0x00, 0x00, 0x1b, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x55, 0x52,
  0x89, 0xe4, 0xc6, 0x90, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x53, 0x6c,
  0x6f, 0x74, 0x00, 0xbf, 0x00, 0x00, 0x24, 0x43, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0xd9, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x08, 0x45,
  0x00, 0x00, 0x08, 0x65, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x1e, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x19, 0x18, 0x28, 0x19, 0x91, 0x6f, 0x00, 0x10, 0x18,
  0x28, 0x19, 0x91, 0x1a, 0x40, 0x5f, 0x00, 0x11, 0x22, 0x02, 0xbf, 0xbf,
  0x00, 0x00, 0x18, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x39,
  0x00, 0x00, 0x06, 0x81, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x06, 0x99,
  0x00, 0x00, 0x14, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x4d,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf9, 0x00, 0x00, 0x14, 0x41,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x4d, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x65
	};
	data_queue_.push(Dock::Data {
		.data_ = data,
		.size_ = sizeof(data),
		.pos_ = 0,
		.start_frame_ = true, // we want to start with a start frame marker
		.end_frame_ = true, // we want to end with an end frame marker
		.free_after_send_ = false, // we don't want to free the data after sending
	});
	Log.logf("\r\n---------- %d ---------\r\n", sizeof(data));
}


#if 0

bool MNPFilter::reply_newtdockdock() {
	if (kLogMNDock) Log.log("MNP: Pushing newtdockdock\r\n");
	Frame *lt = acquire_out_frame();
	if (!lt) {
		if (kLogMNDock) Log.log("MNP: newtdockdock: no out frame available\r\n");
		return false;
	}
	// reply with <16. <10. <02. <02. <04. <01. "newtdockdock" <00. <00. <00. <04. <00. <00. <00. <01. <10. <03. <BA. <4FO
	// 'newt', 'dock', 'dock', 4, 1
	out_seq_no_++;
	lt->header.push_back(kMNP_Frame_LT);
	lt->header.push_back(out_seq_no_);
	lt->data = { 
		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b,
		0x64, 0x6f, 0x63, 0x6b, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x04
		// 0x00, 0x00, 0x00, 0x01
	};
	lt->prepare_to_send();
	// TODO: enqueue the frame to the outgoing pipe
	newton_job_list.push(Event(Event::Type::MNP, Event::Subtype::MNP_SEND_LT, lt->pool_index));
	return true;
}

bool MNPFilter::reply_newtdockstim() {
	if (kLogMNDock) Log.log("MNP: Pushing newtdockstim\r\n");
	Frame *lt = acquire_out_frame();
	if (!lt) {
		if (kLogMNDock) Log.log("MNP: newtdockstim: no out frame available\r\n");
		return false;
	}
	out_seq_no_++;
	lt->header.push_back(kMNP_Frame_LT);
	lt->header.push_back(out_seq_no_);
	// <04. <04. "newtdockstim"  <00. <00. <00. <04. <00. <00. <00. <5AZ
	lt->data = { 
		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b,
		0x73, 0x74, 0x69, 0x6d, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x5A
	};
	lt->prepare_to_send();
	// TODO: enqueue the frame to the outgoing pipe
	newton_job_list.push(Event(Event::Type::MNP, Event::Subtype::MNP_SEND_LT, lt->pool_index));
	return true;
}

bool MNPFilter::reply_newtdocklpkg() {
	if (kLogMNDock) Log.log("MNP: Pushing newtdocklpkg\r\n");
	Frame *lt = acquire_out_frame();
	if (!lt) {
		if (kLogMNDock) Log.log("MNP: newtdocklpkg: no out frame available\r\n");
		return false;
	}
	out_seq_no_++;
	lt->header.push_back(kMNP_Frame_LT);
	lt->header.push_back(out_seq_no_);
	// <04. <04. "newtdocklpkg"  
	lt->data = { 
		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b,
		0x6c, 0x70, 0x6b, 0x67,
		// length of package (32)
		// package data, padded to 4 bytes
		0x00, 0x00, 0x00, 0x04, 0x31, 0x31, 0x31, 0x31
	};
	lt->prepare_to_send();
	// TODO: enqueue the frame to the outgoing pipe
	newton_job_list.push(Event(Event::Type::MNP, Event::Subtype::MNP_SEND_LT, lt->pool_index));
	return true;
}


bool MNPFilter::reply_newtdockdisc() {
	if (kLogMNDock) Log.log("MNP: Pushing newtdockdisc\r\n");
	Frame *lt = acquire_out_frame();
	if (!lt) {
		if (kLogMNDock) Log.log("MNP: newtdockdisc: no out frame available\r\n");
		return false;
	}
	out_seq_no_++;
	lt->header.push_back(kMNP_Frame_LT);
	lt->header.push_back(out_seq_no_);
	// <04. <04. "newtdockdisc"  <00. <00. <00. <00
	lt->data = { 
		0x6e, 0x65, 0x77, 0x74, 0x64, 0x6f, 0x63, 0x6b,
		0x64, 0x69, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00
	};
	lt->prepare_to_send();
	// TODO: enqueue the frame to the outgoing pipe
	newton_job_list.push(Event(Event::Type::MNP, Event::Subtype::MNP_SEND_LT, lt->pool_index));
	return true;
}

/*
 * To send a pacage, we get the following flow:
 * Newton | Dock
 *     LR |
 *        | LR
 *     LA |
 *   rtdk | LA			request to dock: len = 4, uint32 protocol version (1 or 4)
 *     LA | dock    	initiate docking: len = 4, uint32 session type
 *   name | LA			Newton name: length, version info, name (UTF-16z)
 *     LA | stim		Set Timeout: timeout in seconds (usually 30 secs)
 *   dres | LA			Result: reply to Frames that don't need any other reply
 *  -- repeat for every file:
 *     LA | lpkg		Load Package: size in byte, binary data (pad to 4)
 *     LA | <data>*n	More binary data until all data is sent
 *   dres | LA			Result: so we know the Newton is still alive
 * -- all files sent:
 *     LA | disc		Disconnect: no data
 *     LD |
 */

bool MNPFilter::handle_LT(Frame *frame) {
	// TODO: make a super quick marker in the frame if we need a new LT frame, so we don't hold ourselves up here reinterpreting the job
	bool job_done = true;
	// frame->print();
	if ((frame->data.size() >= 12) && (strncmp((const char*)frame->data.data(), "newtdock", 8) == 0)) {
		char buf[5];
		uint32_t cmd; memcpy(&cmd, (const char*)frame->data.data() + 8, 4);
		strncpy(buf, (const char*)frame->data.data() + 8, 4);
		buf[4] = 0;
		if (kLogMNDock) Log.log("\r\nNewton Dock command: ");
		if (kLogMNDock) Log.log(buf);
		if (kLogMNDock) Log.log("\r\n");
#if 0
		if (cmd == ND_FOURCC('r','t','d','k')) {
			job_done = reply_newtdockdock();
		} else if (cmd == ND_FOURCC('n','a','m','e')) {
			job_done = reply_newtdockstim();
		} else if (cmd == ND_FOURCC('d','r','e','s')) {
			if (dock_state_==0) {
				job_done = reply_newtdocklpkg();
				dock_state_ = 1;
			} else {
				job_done = reply_newtdockdisc();
			}
		}
#else
        // TODO: place this Frame in the out_to_dock job pipeline
        dock.out()->send(Event(Event::Type::MNP, Event::Subtype::MNP_FRAME_START));
        for (auto c: frame->data) {
            dock.out()->send(c);
        }
        dock.out()->send(Event(Event::Type::MNP, Event::Subtype::MNP_FRAME_END));
        job_done = true; // we don't handle this here, but in the Dock class
#endif
	} else {
		if (kLogMNDock) Log.log("Newton Dock: no signature found\r\n");
	}
	if (job_done)
	 	release_in_frame(frame);	
	return job_done;
}


#if 0

/* Structure definition */
#define uchar unsigned char
#define ushort unsigned short
typedef struct {
	char devName[256];
	int speed;
	} NewtDevInfo;

/* Constants definition */
#define MaxHeadLen 256
#define MaxInfoLen 256
extern uchar LRFrame[];
extern uchar LDFrame[];

/* Function prototype */
int InitNewtDev(NewtDevInfo *newtDevInfo);
void FCSCalc(ushort *fcsWord, uchar octet);
void SendFrame(int newtFd, uchar *head, uchar *info, int infoLen);
void SendLTFrame(int newtFd, uchar seqNo, uchar *info, int infoLen);
void SendLAFrame(int newtFd, uchar seqNo);
int RecvFrame(int newtFd, uchar *frame);
int WaitLAFrame(int newtFd, uchar seqNo);
int WaitLDFrame(int newtFd);
void ErrHandler(char *errMesg);
void SigInt(int sigNo);

/* UnixNPI */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include "newtmnp.h"

#define VERSION "1.1.5"

#define TimeOut 30

/* Function prototype */
void SigAlrm(int sigNo);

#define NUM_STARS 32

static char* stars(int number) {
	static char string[NUM_STARS+1];
	int i;
	for(i=0; i<NUM_STARS; i++) {
		if(i<number) string[i]='*';
		else string[i]=' ';
	}
	string[NUM_STARS]='\0';
	return string;
}

int main(int argc, char *argv[])
{
	FILE *inFile;
	long inFileLen;
	long tmpFileLen;
	uchar sendBuf[MaxHeadLen + MaxInfoLen];
	uchar recvBuf[MaxHeadLen + MaxInfoLen];
	NewtDevInfo newtDevInfo;
	int newtFd;
	uchar ltSeqNo;
	int i, j, k;

	k = 1;

	/* Initialization */
	fprintf(stdout, "\n");
	fprintf(stdout, "UnixNPI - a Newton Package Installer for Unix platforms\n");
	fprintf(stdout, "Version " VERSION " by Richard C. L. Li, Victor Rehorst, Chayam Kirshen\n");
	fprintf(stdout, "patches by Phil <phil@squack.COM>, Heinrik Lipka\n");
	fprintf(stdout, "This program is distributed under the terms of the GNU GPL: see the file COPYING\n");

	strcpy(newtDevInfo.devName, "/dev/newton");

	/* Install time out function */
	if(signal(SIGALRM, SigAlrm) == SIG_ERR)
		ErrHandler("Error in setting up timeout function!!");

	/* Check arguments */
	if(argc < 2)
		ErrHandler("Usage: unixnpi [-s speed] [-d device] PkgFiles...");
	else
	{
		if (strcmp(argv[1],"-s") == 0)
		{
			if (argc < 4)
				ErrHandler("Usage: unixnpi [-s speed] [-d device] PkgFiles...");
			newtDevInfo.speed = atoi(argv[2]);
			k = 3;
		}
		else
		{
			newtDevInfo.speed = 38400;
			k = 1;
		}
		if (strcmp(argv[k],"-d")==0)
		{
			if (argc<(k+1))
				ErrHandler("Usage: unixnpi [-s speed] [-d device] PkgFiles...");
			strcpy(newtDevInfo.devName, argv[k+1]);
			k+=2;
		}
	}

	/* Initialize Newton device */
	if((newtFd = InitNewtDev(&newtDevInfo)) < 0)
		ErrHandler("Error in opening Newton device!!\nDo you have a symlink to /dev/newton?");
	ltSeqNo = 0;

	/* Waiting to connect */
	fprintf(stdout, "\nWaiting to connect\n");
	do {
		while(RecvFrame(newtFd, recvBuf) < 0);
	} while(recvBuf[1] != '\x01');
	fprintf(stdout, "Connected\n");
	fprintf(stdout, "Handshaking");
	fflush(stdout);

	/* Send LR frame */
	alarm(TimeOut);
	do {
		SendFrame(newtFd, LRFrame, NULL, 0);
		} while(WaitLAFrame(newtFd, ltSeqNo) < 0);
	ltSeqNo++;
	fprintf(stdout, ".");
	fflush(stdout);

	/* Wait LT frame newtdockrtdk */
	while(RecvFrame(newtFd, recvBuf) < 0 || recvBuf[1] != '\x04');
	SendLAFrame(newtFd, recvBuf[2]);
	fprintf(stdout, ".");
	fflush(stdout);

	/* Send LT frame newtdockdock */
	alarm(TimeOut);
	do {
		SendLTFrame(newtFd, ltSeqNo, "newtdockdock\0\0\0\4\0\0\0\4", 20);
	} while(WaitLAFrame(newtFd, ltSeqNo) < 0);
	ltSeqNo++;
	fprintf(stdout, ".");
	fflush(stdout);

	/* Wait LT frame newtdockname */
	alarm(TimeOut);
	while(RecvFrame(newtFd, recvBuf) < 0 || recvBuf[1] != '\x04');
	SendLAFrame(newtFd, recvBuf[2]);
	fprintf(stdout, ".");
	fflush(stdout);

	/* Get owner name */
	i = recvBuf[19] * 256 * 256 * 256 + recvBuf[20] * 256 * 256 + recvBuf[21] *
		256 + recvBuf[22];
	i += 24;
	j = 0;
	while(recvBuf[i] != '\0') {
		sendBuf[j] = recvBuf[i];
		j++;
		i += 2;
		}
	sendBuf[j] = '\0';

	/* Send LT frame newtdockstim */
	alarm(TimeOut);
	do {
		SendLTFrame(newtFd, ltSeqNo, "newtdockstim\0\0\0\4\0\0\0\x1e", 20);
	} while(WaitLAFrame(newtFd, ltSeqNo) < 0);
	ltSeqNo++;
	fprintf(stdout, ".");
	fflush(stdout);

	/* Wait LT frame newtdockdres */
	alarm(TimeOut);
	while(RecvFrame(newtFd, recvBuf) < 0 || recvBuf[1] != '\x04');
	SendLAFrame(newtFd, recvBuf[2]);
	fprintf(stdout, ".\n");
	fflush(stdout);

	/* batch install all of the files */
	for (k; k < argc; k++)
	{
		/* load the file */
		if((inFile = fopen(argv[k], "rb")) == NULL)
			ErrHandler("Error in opening package file!!");
		fseek(inFile, 0, SEEK_END);
		inFileLen = ftell(inFile);
		rewind(inFile);
		/* printf("File is '%s'\n", argv[k]); */

		/* Send LT frame newtdocklpkg */
		alarm(TimeOut);
		strcpy(sendBuf, "newtdocklpkg");
		tmpFileLen = inFileLen;
		for(i = 15; i >= 12; i--) {
			sendBuf[i] = tmpFileLen % 256;
			tmpFileLen /= 256;
			}
		do {
			SendLTFrame(newtFd, ltSeqNo, sendBuf, 16);
		} while(WaitLAFrame(newtFd, ltSeqNo) < 0);
		ltSeqNo++;
		/* fprintf(stdout, ".\n"); */

		/* fprintf(stdout, "Sending %d / %d\r", 0, inFileLen); */
		fprintf(stdout, "%20s %3d%% |%s| %d\r",
			argv[k], 0, stars(0), 0);
		fflush(stdout);

		/* Send package data */
		while(!feof(inFile)) {
                        int bytes;
			alarm(TimeOut);
			i = fread(sendBuf, sizeof(uchar), MaxInfoLen, inFile);
			while(i % 4 != 0)
				sendBuf[i++] = '\0';
			do {
				SendLTFrame(newtFd, ltSeqNo, sendBuf, i);
			} while(WaitLAFrame(newtFd, ltSeqNo) < 0);
			ltSeqNo++;
			if(ltSeqNo % 4 == 0) {
				/* fprintf(stdout, "Sending %d / %d\r", ftell(inFile), inFileLen); */
				bytes=ftell(inFile);
				fprintf(stdout, "%20s %3d%% |%s| %d\r",
					argv[k],
					(int)(((float)bytes/(float)inFileLen)*100),
					stars(((float)bytes/(float)inFileLen)*NUM_STARS),
					bytes);
				fflush(stdout);
			}
		}
		/* fprintf(stdout, "Sending %d / %d\n", inFileLen, inFileLen); */
		fprintf(stdout, "\n");

		/* Wait LT frame newtdockdres */
		alarm(TimeOut);
		while(RecvFrame(newtFd, recvBuf) < 0 || recvBuf[1] != '\x04');
		SendLAFrame(newtFd, recvBuf[2]);

		fclose (inFile);

	} /* END OF FOR LOOP */

	/* Send LT frame newtdockdisc */
	alarm(TimeOut);
	do {
		SendLTFrame(newtFd, ltSeqNo, "newtdockdisc\0\0\0\0", 16);
	} while(WaitLAFrame(newtFd, ltSeqNo) < 0);

	/* Wait disconnect */
	alarm(0);
	WaitLDFrame(newtFd);
	fprintf(stdout, "Finished!!\n\n");

	/* fclose(inFile); */
	close(newtFd);
	return 0;
}

void SigAlrm(int sigNo)
{
	ErrHandler("Timeout error, connection stopped!!");
}
  


#include <stdio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <unistd.h>
#include "newtmnp.h"

/* Constants definition */
uchar FrameStart[] = "\x16\x10\x02";
uchar FrameEnd[] = "\x10\x03";
uchar LRFrame[] = {
	'\x17', /* Length of header */
	'\x01', /* Type indication LR frame */
	'\x02', /* Constant parameter 1 */
	'\x01', '\x06', '\x01', '\x00', '\x00', '\x00', '\x00', '\xff',
		/* Constant parameter 2 */
	'\x02', '\x01', '\x02', /* Octet-oriented framing mode */
	'\x03', '\x01', '\x01', /* k = 1 */
	'\x04', '\x02', '\x40', '\x00', /* N401 = 64 */
	'\x08', '\x01', '\x03' /* N401 = 256 & fixed LT, LA frames */
	};
uchar LDFrame[] = {
	'\x04', /* Length of header */
	'\x02', /* Type indication LD frame */
	'\x01', '\x01', '\xff'
	};

int intNewtFd;

int InitNewtDev(NewtDevInfo *newtDevInfo)
{
	int newtFd;
	struct termios newtTty;

	/*  Install Ctrl-C function */
	intNewtFd = -1;
	if(signal(SIGINT, SigInt) == SIG_ERR)
		ErrHandler("Error in setting up interrupt function!!");

	/* Open the Newton device */
	if((newtFd = open(newtDevInfo->devName, O_RDWR)) == -1)
		return -1;

	/* Get the current device settings */
	tcgetattr(newtFd, &newtTty);

	/* Change the device settings */
	newtTty.c_iflag = IGNBRK | INPCK;
	newtTty.c_oflag = 0;
	newtTty.c_cflag = CREAD | CLOCAL | CS8 & ~PARENB & ~PARODD & ~CSTOPB;
	newtTty.c_lflag = 0;
	newtTty.c_cc[VMIN] = 1;
	newtTty.c_cc[VTIME] = 0;

	/* Select the communication speed */
	switch(newtDevInfo->speed) {
		#ifdef B2400
		case 2400:
			cfsetospeed(&newtTty, B2400);
			cfsetispeed(&newtTty, B2400);
			break;
		#endif
		#ifdef B4800
		case 4800:
			cfsetospeed(&newtTty, B4800);
			cfsetispeed(&newtTty, B4800);
			break;
		#endif
		#ifdef B9600
		case 9600:
			cfsetospeed(&newtTty, B9600);
			cfsetispeed(&newtTty, B9600);
			break;
		#endif
		#ifdef B19200
		case 19200:
			cfsetospeed(&newtTty, B19200);
			cfsetispeed(&newtTty, B19200);
			break;
		#endif
		#ifdef B38400
		case 38400:
			cfsetospeed(&newtTty, B38400);
			cfsetispeed(&newtTty, B38400);
			break;
		#endif
		#ifdef B57600
		case 57600:
			cfsetospeed(&newtTty, B57600);
			cfsetispeed(&newtTty, B57600);
			break;
		#endif
		#ifdef B115200
		case 115200:
			cfsetospeed(&newtTty, B115200);
			cfsetispeed(&newtTty, B115200);
			break;
		#endif
		#ifdef B230400
		case 230400:
			cfsetospeed(&newtTty, B230400);
			cfsetispeed(&newtTty, B230400);
			break;
		#endif
		default:
			close(newtFd);
			return -1;
		}

	/* Flush the device and restarts input and output */
	tcflush(newtFd, TCIOFLUSH);
	tcflow(newtFd, TCOON);

	/* Update the new device settings */
	tcsetattr(newtFd, TCSANOW, &newtTty);

	/* Return with file descriptor */
	intNewtFd = newtFd;
	return newtFd;
}

void FCSCalc(ushort *fcsWord, unsigned char octet)
{
	int i;
	uchar pow;

	pow = 1;
	for(i = 0; i < 8; i++) {
		if((((*fcsWord % 256) & 0x01) == 0x01) ^ ((octet & pow) == pow))
			*fcsWord = (*fcsWord / 2) ^ 0xa001;
		else
			*fcsWord /= 2;
		pow *= 2;
		}
}

void SendFrame(int newtFd, uchar *head, uchar *info, int infoLen)
{
	char errMesg[] = "Error in writing to Newton device, connection stopped!!";
	int i;
	ushort fcsWord;
	uchar buf;

	/* Initialize */
	fcsWord = 0;

	/* Send frame start */
	if(write(newtFd, FrameStart, 3) < 0)
		ErrHandler(errMesg);

	/* Send frame head */
	for(i = 0; i <= head[0]; i++) {
		FCSCalc(&fcsWord, head[i]);
		if(write(newtFd, &head[i], 1) < 0)
			ErrHandler(errMesg);
		if(head[i] == FrameEnd[0]) {
			if(write(newtFd, &head[i], 1) < 0)
				ErrHandler(errMesg);
			}
		}

	/* Send frame information */
	if(info != NULL) {
		for(i = 0; i < infoLen; i++) {
			FCSCalc(&fcsWord, info[i]);
			if(write(newtFd, &info[i], 1) < 0)
				ErrHandler(errMesg);
			if(info[i] == FrameEnd[0]) {
				if(write(newtFd, &info[i], 1) < 0)
					ErrHandler(errMesg);
				}
			}
		}

	/* Send frame end */
	if(write(newtFd, FrameEnd, 2) < 0)
		ErrHandler(errMesg);
	FCSCalc(&fcsWord, FrameEnd[1]);

	/* Send FCS */
	buf = fcsWord % 256;
	if(write(newtFd, &buf, 1) < 0)
		ErrHandler(errMesg);
	buf = fcsWord / 256;
	if(write(newtFd, &buf, 1) < 0)
		ErrHandler(errMesg);

	return;
}

void SendLTFrame(int newtFd, uchar seqNo, uchar *info, int infoLen)
{
	uchar ltFrameHead[3] = {
		'\x02', /* Length of header */
		'\x04', /* Type indication LT frame */
		};

	ltFrameHead[2] = seqNo;
	SendFrame(newtFd, ltFrameHead, info, infoLen);

	return;
}

void SendLAFrame(int newtFd, uchar seqNo)
{
	uchar laFrameHead[4] = {
		'\x03', /* Length of header */
		'\x05', /* Type indication LA frame */
		'\x00', /* Sequence number */
		'\x01' /* N(k) = 1 */
		};

	laFrameHead[2] = seqNo;
	SendFrame(newtFd, laFrameHead, NULL, 0);

	return;
}

int RecvFrame(int newtFd, unsigned char *frame)
{
	char errMesg[] = "Error in reading from Newton device, connection stopped!!";
	int state;
	unsigned char buf;
	unsigned short fcsWord;
	int i;

	/* Initialize */
	fcsWord = 0;
	i = 0;

	/* Wait for head */
	state = 0;
	while(state < 3) {
		if(read(newtFd, &buf, 1) < 0)
			ErrHandler(errMesg);
    //printf("Received %02x\n", buf);
		switch(state) {
			case 0:
				if(buf == FrameStart[0])
					state++;
				break;
			case 1:
				if(buf == FrameStart[1])
					state++;
				else
					state = 0;
				break;
			case 2:
				if(buf == FrameStart[2])
					state++;
				else
					state = 0;
				break;
			}
		}

	/* Wait for tail */
	state = 0;
	while(state < 2) {
		if(read(newtFd, &buf, 1) < 0)
			ErrHandler(errMesg);
		switch(state) {
			case 0:
				if(buf == '\x10')
					state++;
				else {
					FCSCalc(&fcsWord, buf);
					if(i < MaxHeadLen + MaxInfoLen) {
						frame[i] = buf;
						i++;
						}
					else
						return -1;
					}
				break;
			case 1:
				if(buf == '\x10') {
					FCSCalc(&fcsWord, buf);
					if(i < MaxHeadLen + MaxInfoLen) {
						frame[i] = buf;
						i++;
						}
					else
						return -1;
					state = 0;
					}
				else {
					if(buf == '\x03') {
						FCSCalc(&fcsWord, buf);
						state++;
						}
					else
						return -1;
					}
				break;
			}
		}

	/* Check FCS */
	if(read(newtFd, &buf, 1) < 0)
		ErrHandler(errMesg);
	if(fcsWord % 256 != buf)
		return -1;
	if(read(newtFd, &buf, 1) < 0)
		ErrHandler(errMesg);
	if(fcsWord / 256 != buf)
		return -1;

	if(frame[1] == '\x02')
		ErrHandler("Newton device disconnected, connection stopped!!");
	return 0;
}

int WaitLAFrame(int newtFd, uchar seqNo)
{
	uchar frame[MaxHeadLen + MaxInfoLen];

	do {
		while(RecvFrame(newtFd, frame) < 0);
		if(frame[1] == '\x04')
			SendLAFrame(newtFd, frame[2]);
		} while(frame[1] != '\x05');
	if(frame[2] == seqNo)
		return 0;
	else
		return -1;
}

int WaitLDFrame(int newtFd)
{
	char errMesg[] = "Error in reading from Newton device, connection stopped!!";
	int state;
	unsigned char buf;
	unsigned short fcsWord;
	int i;

	/* Initialize */
	fcsWord = 0;
	i = 0;

	/* Wait for head */
	state = 0;
	while(state < 5) {
		if(read(newtFd, &buf, 1) < 0)
			ErrHandler(errMesg);
		switch(state) {
			case 0:
				if(buf == FrameStart[0])
					state++;
				break;
			case 1:
				if(buf == FrameStart[1])
					state++;
				else
					state = 0;
				break;
			case 2:
				if(buf == FrameStart[2])
					state++;
				else
					state = 0;
				break;
			case 3:
				FCSCalc(&fcsWord, buf);
				state++;
				break;
			case 4:
				if(buf == '\x02') {
					FCSCalc(&fcsWord, buf);
					state++;
					}
				else {
					state = 0;
					fcsWord = 0;
					}
				break;
			}
		}

	/* Wait for tail */
	state = 0;
	while(state < 2) {
		if(read(newtFd, &buf, 1) < 0)
			ErrHandler(errMesg);
		switch(state) {
			case 0:
				if(buf == '\x10')
					state++;
				else
					FCSCalc(&fcsWord, buf);
				break;
			case 1:
				if(buf == '\x10') {
					FCSCalc(&fcsWord, buf);
					state = 0;
					}
				else {
					if(buf == '\x03') {
						FCSCalc(&fcsWord, buf);
						state++;
						}
					else
						return -1;
					}
				break;
			}
		}

	/* Check FCS */
	if(read(newtFd, &buf, 1) < 0)
		ErrHandler(errMesg);
	if(fcsWord % 256 != buf)
		return -1;
	if(read(newtFd, &buf, 1) < 0)
		ErrHandler(errMesg);
	if(fcsWord / 256 != buf)
		return -1;

	return 0;
}

void ErrHandler(char *errMesg)
{
	fprintf(stderr, "\n");
	fprintf(stderr, errMesg);
	fprintf(stderr, "\n\n");
	_exit(0);
}

void SigInt(int sigNo)
{
	if(intNewtFd >= 0) {
		/* Wait for all buffer sent */
		tcdrain(intNewtFd);

		SendFrame(intNewtFd, LDFrame, NULL, 0);
		}
	ErrHandler("User interrupted, connection stopped!!");
}


#endif

#endif